'#######################################################################################################################
'#######################################################################################################################
'                                                 U   C   H   i   l   l
'                                                      Base Script
'#######################################################################################################################
'
' Summary
'     Simulates cooling and heating aspects of the vehicle, including the environmental impact on the vehicle's
'     temperature and humidity.
'
'     This script is part of the "Universal Cooling & Heating script for OMSI 2 (UCHill)" modification:
'     <https://github.com/unorthodox-paradox/omsi_2_uchill/>
'     UCHill is public domain content, released under the Unlicense:
'     <https://unlicense.org>
'
'#######################################################################################################################
'
' Dependencies
'     This is a portable script, that is, one that is free of direct dependencies, thus, in principle, one that is
'     compatible with any OMSI vehicle. Vehicle-specific integration logic is handled by the implementation of the
'     <uchill_integration__xxx> group of "adapter macros", normally residing in a separate script.
'
'#######################################################################################################################
'
' See also
'     <.\uchill_vars.txt>
'     <.\uchill_consts.txt>
'
'#######################################################################################################################
'#######################################################################################################################

'---------------------
'     Main Macros
'---------------------

' Init
'-----------------------------------------------------------------------------------------------------------------------
{macro:uchill_init}
    (L.S.Weather_Temperature) (S.L.Cabinair_Temp) (S.L.driver_ac_t) (S.L.passenger_ac_t) (S.L.cabin_heater_t)
    (L.S.Weather_AbsHum) (S.L.Cabinair_absHum)
    
    (M.L.uchill_integration__init)
' one of those macros--normally the first--should at the very least set <uchill_integration__cabinair_V> needed below
    (M.L.uchill_integration__acquire_static_vehicle_attributes)
    (M.L.uchill_integration__acquire_dynamic_vehicle_attributes)

' these are set to a high value initially, to avoid division by 0 (they are used as divisors--see sound macros--prior
'  to actually having been set, during first frame execution)
    (C.L.generic_high_value) (S.L.cabinair_Vrate_driver_ac_max) (S.L.cabinair_Vrate_passenger_ac_max)
        (S.L.cabinair_Vrate_cabin_heater_max)
    
' the following sub-products used by <ghe_impact> are constant, thus only calculated once
    (C.L.ghe_time_max) s0 (C.L.cabinair_Qrate_env_factor) * (C.L.cabinair_cvm) /
        (C.L.ghe_env_conduction_resistance_factor) * (S.L.ghe_env_conduction_resistance_const)
    l0 (L.L.uchill_integration__cabinair_V) / s0 (C.L.ghe_env_convection_resistance_factor) *
        (S.L.ghe_env_convection_resistance_const) l0 (C.L.ghe_ac_resistance_factor) *
        (S.L.ghe_ac_resistance_const)
{end}

' Frame
'-----------------------------------------------------------------------------------------------------------------------
{macro:uchill_frame}
' portable retrieval of vehicle state
    (M.L.uchill_integration__acquire_dynamic_vehicle_attributes)
    (M.L.uchill_integration__acquire_vehicle_state)

' execution of actual script-specific logic
    (M.L.cabinair_frame)
    (M.L.actualize_panel_leds)
    (M.L.debug)

' portable adjustment of vehicle state
    (M.L.uchill_integration__actualize_vehicle_state)
{end}

'----------------------------------
'     <uchill_frame> delegates
'----------------------------------

' Remnant of the original script. My (i.e., u.p.'s) changes have been, for the most part, moved into separate macros,
' which are called by this one.
'-----------------------------------------------------------------------------------------------------------------------
{macro:cabinair_frame}
    (L.L.Cabinair_Temp) s3
    (L.L.uchill_integration__electrics_on) s4
    (L.L.uchill_integration__engine_running) s5
    (L.S.Weather_Temperature) s6
    (L.S.Timegap) (S.L._r9)

' sound-related
    (M.L.actualize_driver_ac_sound)
    (M.L.actualize_passenger_ac_sound)
    (M.L.actualize_ext_ac_sound)
    (M.L.actualize_cabin_heater_sound)
    (M.L.actualize_auxheat_sound)

' Berechnung der Luefterbeschleunigung:

' Berechnung der Raten:
    l3 l6 - (C.L.cabinair_Qrate_env_factor) * (S.L.cabinair_Qrate_env_conduction)

' Direkte Ableitung der Motorwärme in den Fahrgastraum
    (L.L.uchill_integration__engine_t_env) l3 - (C.L.cabinair_Qrate_engine_factor) * (S.L.cabinair_Qrate_engine)

' temperature- and status-related
    (M.L.calculate_driver_ac_temps)
    (M.L.actualize_driver_ac_status)
    (M.L.calculate_passenger_ac_temps)
    (M.L.actualize_passenger_ac_status)
    (M.L.actualize_auto_humidity_management_status)
    (M.L.actualize_ac_humidity_management_status)
    (M.L.calculate_cabin_heater_temps)
    (M.L.actualize_cabin_heater_status)
    (M.L.actualize_auxheat_status)

' Berechnung der effektiven Gesamt-Luftaustauschfläche:
    (L.L.uchill_integration__number_of_inward_swinging_door_wings)
        (L.L.uchill_integration__number_of_outward_swinging_door_wings) +
        (L.L.uchill_integration__number_of_outward_sliding_door_wings) + (C.L.cabinair_A_per_door_wing) s0 *
        (L.L.uchill_integration__number_of_folding_passenger_windows) (C.L.cabinair_A_per_folding_passenger_window) s1
        * + (C.L.cabinair_A_sliding_driver_window) s2 + (L.L.uchill_integration__number_of_hatches)
        (C.L.cabinair_A_per_backwards_open_hatch) (C.L.cabinair_A_per_forwards_open_hatch) + * +
        (S.L.cabinair_A_openable_surfaces)
    (L.L.uchill_integration__door_state_sum) l0 * (L.L.uchill_integration__passenger_window_state_sum) l1 * +
        (L.L.uchill_integration__driver_window_state) l2 * + s0
' hatch contribution varies based on velocity sign, not just the formers' state; the thresholds are needed due to the
'  fact that <velocity> tends to actually be non-zero (albeit "infinitely" small) when at a standstill
    (L.L.uchill_integration__hatch_forward_state_sum) s1
    (L.L.uchill_integration__hatch_backward_state_sum) s2
    (L.L.velocity) (C.L.generic_velocity_min) >
    {if}
        l1 (C.L.cabinair_A_per_forwards_open_hatch) * s1
        l2 (C.L.cabinair_A_per_backwards_open_hatch) * s2
    {else}
        (L.L.velocity) (C.L.generic_velocity_min) /-/ <
        {if}
            l1 (C.L.cabinair_A_per_backwards_open_hatch) * s1
            l2 (C.L.cabinair_A_per_forwards_open_hatch) * s2
        {else}
            l1 (C.L.cabinair_A_per_hatch_at_standstill) * s1
            l2 (C.L.cabinair_A_per_hatch_at_standstill) * s2
        {endif}
    {endif}
' compute the overall area of air exchange; the lower bound expresses imperfect isolation 
    l0 l1 + l2 + (L.L.uchill_integration__number_of_inward_swinging_door_wings)
        (C.L.cabinair_A_per_inward_swinging_door_wing_min) *
        (L.L.uchill_integration__number_of_outward_swinging_door_wings)
        (C.L.cabinair_A_per_outward_swinging_door_wing_min) * +
        (L.L.uchill_integration__number_of_outward_sliding_door_wings)
        (C.L.cabinair_A_per_outward_sliding_door_wing_min) * +
        (L.L.uchill_integration__number_of_folding_passenger_windows) (C.L.cabinair_A_per_folding_passenger_window_min)
        * + (C.L.cabinair_A_sliding_driver_window_min) + (L.L.uchill_integration__number_of_hatches)
        (C.L.cabinair_A_per_hatch_min) * + max (S.L.cabinair_A_open_surfaces)
' Berechnung des Gesamtvolumenstroms in die Außenwelt und umgekehrt (V zählt je Richtung, d.h. insgesamt wird 2*V
'  bewegt)
        (L.L.velocity) 20 / abs (C.L.cabinair_openable_surface_convection_minkmh) +
            (C.L.cabinair_openable_surface_convection_effectiveness) * 3.6 / * (S.L.cabinair_Vrate_open_surfaces)

' air exchane volume-related
    (M.L.calculate_driver_ac_air_exchange_volumes)
    (M.L.calculate_passenger_ac_air_exchange_volumes)
    (M.L.calculate_cabin_heater_air_exchange_volume)

    (L.L.uchill_integration__cabinair_V) s1

' the following are pre-calculated, as <ghe_impact> depends on them
    l6 l3 - l1 / (L.L.cabinair_Vrate_open_surfaces) * (S.L.cabinair_Qrate_env_convection)
    (L.L.driver_ac_t) l3 - l1 / (L.L.cabinair_Vrate_driver_ac) * (S.L.cabinair_Qrate_driver_ac)
    (L.L.uchill_integration__passenger_ac_installed)
    {if}
        (L.L.passenger_ac_t) l3 - l1 / (L.L.cabinair_Vrate_passenger_ac) * (S.L.cabinair_Qrate_passenger_ac)
    {endif}

' greenhouse update
    (M.L.ghe_impact)

    (L.L.Cabinair_Temp) s0
    (L.L.uchill_integration__cabinair_V) s1
    (L.L._r9) s2

' cabin temperature update
' Berechnung der Temperaturrate durch Motor und Abstrahlung an die Umwelt...
    (L.L.cabinair_Qrate_engine) (L.L.cabinair_Qrate_env_conduction) - (C.L.cabinair_cvm) /
' ...and due to greenhouse effect...
        (L.L.cabinair_Qrate_ghe_gross) +
' ...und Temperaturrate durch Passagiere...
        (C.L.cabinair_T_passenger) l0 - l1 / (C.L.cabinair_Vrate_passenger) * (L.L.humans_count) * +
' ...und dieser durch die Volumenströme durch Fenster und Türen:
        (L.L.cabinair_Qrate_env_convection) +
' ...und des Frontheizgerätes...
        (L.L.cabinair_Qrate_driver_ac) +
' ...und der Raumheizgeräte...
        (L.L.cabin_heater_t) l0 - l1 / (L.L.cabinair_Vrate_cabin_heater) * + s3
' ...und der Klimaanlage...
    (L.L.uchill_integration__passenger_ac_installed)
    {if}
        l3 (L.L.cabinair_Qrate_passenger_ac) + s3
    {endif}
' ...aufintegrieren:
    l3 l2 * l0 + (S.L.Cabinair_Temp) s0

' engine heat losses due to cabin heaters and driver A/C, and gains due to auxheat; the engine and/or the adapter
'  script are responsible for taking these factors into account when calculating the vehicle's engine's temperature

' Berechnung der Motorkühlrate durch die Wärmetauscher in den Heizgeräten:
    (L.L.cabin_heater_t) l0 max l0 - l1 / (L.L.cabinair_Vrate_cabin_heater) * s3
' driver A/C only when in engine-assisted mode
    (L.L.driver_ac_running) !
    {if}
        l3 (L.L.driver_ac_t) l0 - 0 max l1 / (L.L.cabinair_Vrate_driver_ac) * + s3
    {endif}
    l3 (C.L.cabinair_cvm) * 8 * (S.L.cabinair_Qrate_engine_fanheatcooling)
    
' engine heat intake due to auxheat
    (L.L.auxheat_active) (C.L.engine_Qrate_auxheat_const) (L.L.cabinair_Qrate_env_conduction) - *
        (S.L.engine_Qrate_auxheat)

    (L.L.Cabinair_absHum) s3
    (L.S.Weather_AbsHum) s7

' cabin humidity update
' Berechnung der Feuchtigkeitsrate durch Volumenströme mit den Passagieren:
    (C.L.cabinair_absHum_passenger) l3 - l1 / (C.L.cabinair_Vrate_passenger) * (L.L.humans_count) *
' Berechnung der Feuchtigkeitsrate durch Volumenströme mit der Außenwelt:
        l7 l3 - l1 / (L.L.cabinair_Vrate_open_surfaces) * +
' Berechnung der Feuchtigkeitsrate durch Frontheizgerät:
        l7 l3 - l1 / (L.L.cabinair_Vrate_driver_ac_humidity) * + (S.L._r9)
' ...und durch Klimaanlage:
    (L.L.uchill_integration__passenger_ac_installed)
    {if}
        (L.L._r9) l7 l3 - l1 / (L.L.cabinair_Vrate_passenger_ac_humidity) * + (S.L._r9)
    {endif}
    (L.L._r9) l2 * l3 + (S.L._r9)
' estimate saturation humidity for cabin temp
    l0 (F.L.saturation_humidity_f_temp) (S.L._r14)
' hack to prevent unrealistic skyrocketing of cabin humidity; this still fails under very low temps (t < ~ -45 oC)
'  though, as my saturation humidities severely diverge from OMSI's respective ones within that range
    (L.L._r9) (L.L._r14) (C.L.rel_cabin_humidity_max) * min (S.L._r9)
' estimate new relative humidity
    (L.L._r9) (L.L._r14) / (C.L.rel_cabin_humidity_max) min (S.L._r8)
' absolute humidity reduction due to A/C-induced dehumidification, if relative humidity above reasonable limit
    (L.L.ac_humidity_management_active) (L.L._r8)
        (C.L.dehumidification_rel_cabin_humidity_min) > &&
    {if}
        1 (C.L.ac_dehumidification_effectiveness) * l2 * l0 (F.L.humidity_management_effectiveness_f_temp) * -
            (L.L._r9) * (S.L._r9)
    {else}
' absolute humidity increase due to A/C-induced humidification, if relative humidity below reasonable limit
        (L.L.ac_humidity_management_active) (L.L._r8) (C.L.humidification_rel_cabin_humidity_max) < &&
        {if}
            1 (L.L._r9) (C.L.ac_humidification_effectiveness) * l2 * l0 (F.L.humidity_management_effectiveness_f_temp)
                * + (L.L._r9) * (S.L._r9)
        {endif}
    {endif}
' assign results
    (L.L._r9) (S.L.Cabinair_absHum)
    (L.L.Cabinair_relHum) (S.L._r8)

' window misting degree update
' disclaimer: none of this is claimed to be scientifically sane, let alone correct
    (M.L.calculate_cabin_window_int_misting_degree)
    (M.L.calculate_cabin_window_ext_misting_degree)
{end}

' Controls the cooling / heating panel's buttons' LEDs.
' Blinking signals that the corresponding function is unavailable, is in the process of starting up, or, in the case of
' <uchill_integration__cp_humidity_management>, has been automatically initiated.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_panel_leds}
    (L.L.uchill_integration__electrics_on)
    {if}
        (L.L.global_led_target) s0
        (L.L.global_led_timer) (L.S.Timegap) + s1 1 >=
        {if}
            l0 ! s0
            0 s1
        {endif}
        l0 (S.L.global_led_target)
        l1 (S.L.global_led_timer)
        (L.L.uchill_integration__cp_driver_ac) (L.L.driver_ac_running) 0 > s1 l0 l1 ! && || &&
            (S.L.uchill_integration__cp_driver_ac_led)
        (L.L.uchill_integration__cp_passenger_ac) (L.L.passenger_ac_running) 0 > s1 l0 l1 ! && || &&
            (S.L.uchill_integration__cp_passenger_ac_led)
' constantly on if button pushed; otherwise blinking if either of the A/C-based functions is in an idle state allowing
'  air flow
        (L.L.uchill_integration__cp_air_circulation) l0 (L.L.uchill_integration__cp_driver_ac)
            (L.L.driver_ac_running) ! && (L.L.cabinair_Vrate_driver_ac_target) &&
            (L.L.uchill_integration__cp_passenger_ac) (L.L.passenger_ac_running) ! &&
            (L.L.cabinair_Vrate_passenger_ac_target) && || && || (S.L.uchill_integration__cp_air_circulation_led)
        (L.L.uchill_integration__cp_auxheat) (L.L.auxheat_active) s1 l0 l1 ! && || &&
            (S.L.uchill_integration__cp_auxheat_led)
        (L.L.uchill_integration__cp_humidity_management) s1
        (L.L.ac_humidity_management_active) s2
        (L.L.cabin_heater_dehumidification_active) s3
' constantly on if button pushed and A/C humidity management or cabin heater-based dehumidification active
' blinking if button pushed and both A/C humidity management and cabin heater-based dehumidification unavailable, or
'  engine off, or button not pushed and A/C humidity management active (implying automatic mode)
' see also the <actualize_auto_humidity_management_status>, <actualize_ac_humidity_management_status> and
'  <actualize_cabin_heater_status> macros
        l1 l2 l3 || && l0 l1 (L.L.uchill_integration__engine_running) ! l2 ! l3 ! && || && l1 ! l2 && || && ||
            (S.L.uchill_integration__cp_humidity_management_led)
        (L.L.uchill_integration__cp_cabin_heaters) (L.L.cabin_heaters_running) s1 l0 l1 ! && || &&
            (S.L.uchill_integration__cp_cabin_heaters_led)
    {else}
        0 (S.L.uchill_integration__cp_driver_ac_led) (S.L.uchill_integration__cp_passenger_ac_led)
            (S.L.uchill_integration__cp_air_circulation_led) (S.L.uchill_integration__cp_auxheat_led)
            (S.L.uchill_integration__cp_humidity_management_led) (S.L.uchill_integration__cp_cabin_heaters_led)
            (S.L.global_led_timer) (S.L.global_led_target)
    {endif}
{end}

' Assigns logical predefined variable groups' values to the debugging variables (which are only displayed in "-debug",
' of course).
'
' Note: Unless real-time updates of the values are desired, saving the current situation and viewing
' <<OMSI>\maps\<map_name>\laststn.osn> in a text editor is typically more convenient, as it provides a snapshot of
' _all_ of the vehicle's variables' values.
'-----------------------------------------------------------------------------------------------------------------------
{macro:debug}
    (C.L.debug_var_group) s0
    {if}
        (L.L.Cabinair_Temp) s1
        (C.L._debug_reg_unused_placeholder) (S.L._r8)
        l0 (C.L._debug_driver_ac_temps_and_v_rates_group_id) =
        {if}
            (L.L.driver_ac_t_target) s2
            (L.L.driver_ac_t) s3
            (L.L.cabinair_Vrate_driver_ac_target) s4
            (L.L.cabinair_Vrate_driver_ac) s5
            (L.L.driver_ac_running) s6
        {else}
            l0 (C.L._debug_passenger_ac_temps_and_v_rates_group_id) =
            {if}
                (L.L.passenger_ac_t_target) s2
                (L.L.passenger_ac_t) s3
                (L.L.cabinair_Vrate_passenger_ac_target) s4
                (L.L.cabinair_Vrate_passenger_ac) s5
                (L.L.passenger_ac_running) s6
            {else}
                l0 (C.L._debug_cabin_heater_temps_and_v_rates_group_id) =
                {if}
                    (L.L.cabin_heater_t_target) s2
                    (L.L.cabin_heater_t) s3
                    (L.L.cabinair_Vrate_cabin_heater_target) s4
                    (L.L.cabinair_Vrate_cabin_heater) s5
                    (L.L.cabin_heaters_running) s6
                {else}
                    l0 (C.L._debug_driver_ac_sounds_group_id) =
                    {if}
                        (L.L.driver_ac_fan_sound_vol_target) s2
                        (L.L.driver_ac_fan_sound_vol) s3
                        (L.L.driver_ac_int_sound_vol_target) s4
                        (L.L.driver_ac_int_sound_vol) s5
                        (L.L._r8) s6
                    {else}
                        l0 (C.L._debug_passenger_ac_sounds_group_id) =
                        {if}
                            (L.L.passenger_ac_fan_sound_vol_target) s2
                            (L.L.passenger_ac_fan_sound_vol) s3
                            (L.L.passenger_ac_int_sound_vol_target) s4
                            (L.L.passenger_ac_int_sound_vol) s5
                            (L.L._r8) s6
                        {else}
                            l0 (C.L._debug_cabin_heater_sound_group_id) =
                            {if}
                                (L.L.cabin_heaters_sound_vol_target) s2
                                (L.L.cabin_heaters_sound_vol) s3
                                (L.L._r8) s4 s5 s6
                            {else}
                                l0 (C.L._debug_ext_ac_sound_group_id) =
                                {if}
                                    (L.L.ac_ext_sound_vol_target) s2
                                    (L.L.ac_ext_sound_vol) s3
                                    (L.L._r8) s4 s5 s6
                                {else}
                                    l0 (C.L._debug_humidity_rates_group_id) =
                                    {if}
                                        (L.L.Cabinair_relHum) s2
                                        (L.L.cabinair_Vrate_driver_ac_humidity) s3
                                        (L.L.cabinair_Vrate_passenger_ac_humidity) s4
                                        (L.L._r8) s5 s6
                                    {else}
                                        l0 (C.L._debug_window_misting_group_id) =
                                        {if}
                                            (L.L.env_dew_point) s2
                                            (L.L.cabin_dew_point) s3
                                            (L.L.cabin_window_int_misting) s4
                                            (L.L.cabin_window_ext_misting) s5
                                            (L.L._r8) s6
                                        {else}
                                            l0 (C.L._debug_ghe_group_id) =
                                            {if}
                                                (L.L.ghe_intensity) s2
                                                (L.L.cabinair_Qrate_ghe_net) s3
                                                (L.L.cabinair_Qrate_ghe_gross) s4
                                                (L.L.ghe_t_increase_target) s5
                                                (L.L.ghe_t_target) s6
                                            {else}
                                                (L.L._r8) s7
                                            {endif}
                                        {endif}
                                    {endif}
                                {endif}
                            {endif}
                        {endif}
                    {endif}
                {endif}
            {endif}
        {endif}
        l7 (L.L._r8) = !
        {if}
            l1 (L.L._r8) s7 = !
            {if}
                l1 (S.L.Debug_0)
            {endif}
            l2 l7 = !
            {if}
                l2 (S.L.Debug_1)
            {endif}
            l3 l7 = !
            {if}
                l3 (S.L.Debug_2)
            {endif}
            l4 l7 = !
            {if}
                l4 (S.L.Debug_3)
            {endif}
            l5 l7 = !
            {if}
                l5 (S.L.Debug_4)
            {endif}
            l6 l7 = !
            {if}
                l6 (S.L.Debug_5)
            {endif}
        {endif}
    {endif}
{end}

'------------------------------------
'     <cabinair_frame> delegates
'------------------------------------

' Updates the driver's A/C's (fan-/A/C-specific, interior) sound volume.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_driver_ac_sound}
' <r4> = <uchill_integration__electrics_on>
' we check for electrics, since we don't want to hear the fan when they're off (the v-rate might, even then, be non-null)
    l4 (L.L.cabinair_Vrate_driver_ac) s0 && (L.L.uchill_integration__cp_driver_ac_fan) &&
    {if}
        l0 (L.L.cabinair_Vrate_driver_ac_max) / s0
    {else}
        0 s0
    {endif}
' fan-specific
    l0 (S.L.driver_ac_fan_sound_vol_target)
' gradual update
    (L.L.driver_ac_fan_sound_vol) (S.L._r10) l0 (S.L._r11) (C.L.driver_ac_fan_sound_update_rate) (S.L._r12)
        (M.L.from_r10_to_r11_at_r12_linear) (L.L._r10) (S.L.driver_ac_fan_sound_vol) s0
' A/C-specific (eco and pre-cooling/-heating modes don't count)
    (L.L.driver_ac_running) 1 = (L.L.driver_ac_fan_sound_vol_target) (C.L.driver_ac_int_sound_min) max *
        (S.L.driver_ac_int_sound_vol_target) s0
' gradual update
    (L.L.driver_ac_int_sound_vol) (S.L._r10) l0 (S.L._r11) (C.L.driver_ac_int_sound_update_rate) (S.L._r12)
        (M.L.from_r10_to_r11_at_r12_linear) (L.L._r10) (S.L.driver_ac_int_sound_vol)
{end}

' Updates the passengers' A/C's (fan-/A/C-specific, interior) sound volume.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_passenger_ac_sound}
    (L.L.cabinair_Vrate_passenger_ac) s0
    {if}
        l0 (L.L.cabinair_Vrate_passenger_ac_max) / s0
    {else}
        0 s0
    {endif}
' fan-specific
    l0 (S.L.passenger_ac_fan_sound_vol_target)
' gradual update
    (L.L.passenger_ac_fan_sound_vol) (S.L._r10) l0 (S.L._r11) (C.L.passenger_ac_fan_sound_update_rate) (S.L._r12)
        (M.L.from_r10_to_r11_at_r12_linear) (L.L._r10) (S.L.passenger_ac_fan_sound_vol) s0
' A/C-specific (eco and pre-cooling/-heating modes don't count)
    l0 (L.L.passenger_ac_running) 1 = && (L.L.ac_humidity_management_active)
        (C.L.ac_humidity_management_passenger_ac_int_sound_contribution) * || (S.L.passenger_ac_int_sound_vol_target)
        s0
' gradual update
    (L.L.passenger_ac_int_sound_vol) (S.L._r10) l0 (S.L._r11) (C.L.passenger_ac_int_sound_update_rate) (S.L._r12)
        (M.L.from_r10_to_r11_at_r12_linear) (L.L._r10) (S.L.passenger_ac_int_sound_vol)
{end}

' Updates the exterior (i.e., the visible--unless deactivated through repaint var, or at runtime--roof-mounted)
' A/C unit's sound volume.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_ext_ac_sound}
' eco mode doesn't count; normal and pre-cooling/-heating modes both do, however
    (L.L.driver_ac_running) abs 1 = (C.L.driver_ac_ac_ext_sound_contribution) * (L.L.passenger_ac_running) abs 1 =
        (L.L.ac_humidity_management_active) || (C.L.passenger_ac_ac_ext_sound_contribution) * +
        (L.L.uchill_integration__passenger_ac_installed) * (S.L.ac_ext_sound_vol_target) s0
' gradual update
    (L.L.ac_ext_sound_vol) (S.L._r10) l0 (S.L._r11) (C.L.ac_ext_sound_update_rate) (S.L._r12)
        (M.L.from_r10_to_r11_at_r12_linear) (L.L._r10) (S.L.ac_ext_sound_vol)
{end}

' Updates the cabin heaters' sound volume.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_cabin_heater_sound}
    (L.L.cabin_heaters_running)
    {if}
        (L.L.cabinair_Vrate_cabin_heater) (L.L.cabinair_Vrate_cabin_heater_max) / s0
    {else}
        0 s0
    {endif}
    l0 (S.L.cabin_heaters_sound_vol_target)
' gradual update    
    (L.L.cabin_heaters_sound_vol) (S.L._r10) l0 (S.L._r11) (C.L.cabin_heater_sound_update_rate) (S.L._r12)
        (M.L.from_r10_to_r11_at_r12_linear) (L.L._r10) (S.L.cabin_heaters_sound_vol)
{end}

' Updates the auxiliary heating's sound volume.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_auxheat_sound}
    (L.L.auxheat_active) (S.L.auxheat_sound_vol_target) s0
' gradual update
    (L.L.auxheat_sound_vol) (S.L._r10) l0 (S.L._r11) (C.L.auxheat_sound_update_rate) (S.L._r12)
        (M.L.from_r10_to_r11_at_r12_linear) (L.L._r10) (S.L.auxheat_sound_vol)
{end}

'-----------------------------------------------------------------------------------------------------------------------
' Short example to help you understand the somewhat convoluted <calculate_xxx_ac_temps> and <actualize_xxx_ac_status>
' macros:
'
' Say that it's reasonably warm and it is decided to cool the vehicle through either of the A/C-based functions. The
' following illustrate what happens once the corresponding button has been pushed. Note that sufficient power supply
' and constant environmental conditions are assumed at all times.
'
' 1. <calculate_xxx_ac_temps> (M1) gets invoked, acknowledges the "on" state of the button, performs various checks
'   and, assuming they all pass, assigns some temp lower than <Cabinair_Temp> to <xxx_ac_t_preview> (V1), as well
'   as the value 1 to <xxx_ac_t_running_target> (V2).
' 2. <actualize_xxx_ac_status> (M2) gets invoked, acknowledges the value of V2 set above and initializes a delay timer,
'   based on V1, among other factors, representing the A/C unit's "inertia" to react to an activation event.
' 3. For a number of subsequent frames, nothing noteworthy occurs, except for M2's incrementation of its aforementioned
'   timer's value.
' 4. Once its timer has expired, M2 sets <xxx_ac_running> (V3) to 1 or -1. The <ac_t_comfortable> (M3) macro's
'   documentation explains the difference. For the sake of completeness, assume it's -1.
' 5. Upon its invocation during executing of the next frame, M1 acknowledges V3's value, assigns V1 to
'   <xxx_ac_t_target> (V4) and begins decrementing <xxx_ac_t> (V5) towards V4.
' 6. Again, nothing worth mentioning changes for a number of frames, except for M1's decrementation of V5.
' 7. Once M3 determines (on M2's behalf) that V5 is low enough, M2 (signalled to do so by M3's outcome) sets V3 to 1,
'   meaning that the A/C is now "officially" active. From that point on--which might lie several minutes ahead of the
'   first step in time--does, at long last, actual cooling of the cabin begin (via
'   <calculate_driver_ac_air_exchange_volumes>, which falls outside of this
'   discussion's scope).
'-----------------------------------------------------------------------------------------------------------------------

' Determines the driver's A/C's output temperature.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_driver_ac_temps}
' A/C-based cooling / heating requested
' <r4> = <uchill_integration__electrics_on>
' <r5> = <uchill_integration__engine_running>
    l4 l5 && (L.L.uchill_integration__cp_driver_ac) &&
    {if}
' first output temp estimation
        (C.L.driver_ac_min_selectable_t) (C.L.driver_ac_min_max_selectable_t_interval)
            (L.L.uchill_integration__cp_driver_ac_t) * + s0
' sanity-check
        (M.L.ac_available) (L.L._r8)
        {if}
' pass; A/C is to be activated
' check if eco mode applies
            (M.L.ac_eco_mode_available) (L.L._r8)
            {if}
' A/C is to be activated in eco mode; but still, don't allow the actual output temp to be cooler than <r0>, when
'  cooling, or warmer than <r0>, when heating
                l3 (C.L.ac_cooling_cabin_t_min) >
                {if}
                    l6 l0 max s2
                {else}
                    l6 l0 min s2
                {endif}
' indicate that <actualize_driver_ac_status> may begin, if it hasn't already, attempting to start the A/C
                2 s1
            {else}
' A/C is to be activated in normal mode
' increase or decrease actual respective cooling or heating output temp, based on its difference from current cabin or
'  env temp, depending on whether recirculation or fresh mode is respectively in effect
' <r3> = <Cabinair_Temp>
                l3 (C.L.ac_cooling_cabin_t_min) >
                {if}
                    (C.L.ac_cooling_loss_per_degree) s7
                {else}
                    (C.L.ac_heating_loss_per_degree) s7
                {endif}
                (L.L.uchill_integration__cp_air_circulation)
                {if}
                    l3 l0 - (S.L._r8)
                {else}
                    l6 l0 - (S.L._r8)
                {endif}
                l0 (L.L._r8) l7 * + s2
' don't allow the A/C to start when the cabin heaters are running and it is very cold; the A/C will be unable to
'  "compete" with the cabin heaters and severely reduce their effectiveness otherwise
                (L.L.cabin_heaters_running) l2 (C.L.ac_heating_cabin_t_max) <= &&
                {if}
                    0 s1
                    l3 s2
                {else}
' indicate that <actualize_driver_ac_status> may begin, if it hasn't already, attempting to start the A/C
                    1 s1
                {endif}
            {endif}
' only update the output temp if <actualize_driver_ac_status> has actually activated the A/C; else wait, using the
'  current cabin temperature instead
            (L.L.driver_ac_running)
            {if}
                l2 s0
            {else}
                l3 s0
            {endif}
        {else}
' fail; A/C will be / stay deactivated
            l3 s0 s2
            0 s1
        {endif}
    {else}
' environment-/engine-based cooling / heating; A/C will be / stay deactivated
        0 s1
        (L.L.uchill_integration__cp_air_circulation)
        {if}
' mix cabin-recirculated with engine-heated air
            l3 s0
        {else}
' mix fresh with engine-heated air
            l6 s0
        {endif}
' purpose of constants:
' - <fan_heater_target_t_engine_factor> reduces the engine-heated air's temperature
'  (we don't want 80+ -degree air entering our cabin)
' - <fan_heater_output_t_increase_max> affects the overall upper bound
        l0 (L.L.uchill_integration__engine_t) l0 max l0 - (L.L.uchill_integration__cp_driver_ac_t) *
            (C.L.fan_heater_target_t_engine_factor) * + l0 (C.L.fan_heater_output_t_increase_max) + min s0 s2
    {endif}
    l0 (S.L.driver_ac_t_target)
    l1 (S.L.driver_ac_running_target)
    l2 (S.L.driver_ac_t_target_preview)
' gradual update
    (M.L.actualize_driver_ac_output_air_temp)
{end}

' Actually (de-)activates the driver's A/C.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_driver_ac_status}
' this is determined via <calculate_driver_ac_temps>
    (L.L.driver_ac_running_target) s2
    {if}
' activation branch
' new start condition (cached for duplication reduction)
' <ac_cooldown_threshold_t_diff> contributes to an "anti-repeat" condition, so as to prevent instantaneous on-off loops
' <r3> = <Cabinair_Temp>
        l3 (C.L.ac_heating_cabin_t_max) (C.L.ac_cooldown_threshold_t_diff) s0 - < l3 (C.L.ac_cooling_cabin_t_min) l0 + >
            || s7
        (L.L.driver_ac_running) 1 = (L.L.passenger_ac_running) 1 = (L.L.ac_humidity_management_active) || l7 && ||
        {if}
' no delay if driver's A/C some other A/C-based function already active; activate (/ resume)
            0 s0
            -1 s1
        {else}
' start anew
            (L.L.driver_ac_start_stop_delay) s1 -1 =
            {if}
                (C.L.driver_ac_start_delay_additional_max) random (C.L.driver_ac_start_delay_min) + s1
                l2 1 =
                {if}
' increase delay based on env-to-target difference (doesn't apply to eco mode)
                    l6 (L.L.driver_ac_t_target_preview) - abs (C.L.driver_ac_start_delay_env_factor) * l1 + s1
                {endif}
            {endif}
' <_r9> = <Timegap>
            (L.L.driver_ac_start_stop_timer) (L.L._r9) + s0 l1 > l7 &&
            {if}
' actually activate
                0 s0
                -1 s1
            {else}
' no change; inactive and stays inactive
                (L.L.driver_ac_running) s2
            {endif}
        {endif}
    {else}
' deactivation branch
        (L.L.driver_ac_running) s2
        {if}
            (L.L.driver_ac_start_stop_delay) s1 -1 =
            {if}
                (C.L.driver_ac_stop_delay_additional_max) random (C.L.driver_ac_stop_delay_min) + s1
            {endif}
' deactivation condition: either direct and _delayed_ (timer-based, when e.g. power is lost or function is switched off
'  by user), or indirect and _instant_ (target cabin temp achieved)
            (L.L.driver_ac_start_stop_timer) (L.L._r9) + s0 l1 > l4 l5 && l3 (C.L.ac_heating_cabin_t_max) >= &&
                l3 (C.L.ac_cooling_cabin_t_min) <= && ||
            {if}
' actually deactivate
                0 s0 s2
                -1 s1
' else: no change; active and stays active
            {endif}
        {else}
' no change; inactive and stays inactive
            0 s0
            -1 s1
        {endif}
    {endif}
    l0 (S.L.driver_ac_start_stop_timer)
    l1 (S.L.driver_ac_start_stop_delay)
' prevent <driver_ac_running> from becoming 1 iff <driver_ac_t> not (yet) in comfort levels
    (L.L.driver_ac_t) s0 (L.L.driver_ac_t_target_preview) s1 (M.L.ac_t_comfortable) l2 (S.L.driver_ac_running)
{end}

' Determines the passengers' A/C's output temperature.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_passenger_ac_temps}
    (L.L.uchill_integration__passenger_ac_installed)
    {if}
' <r4> = <uchill_integration__electrics_on>
' <r5> = <uchill_integration__engine_running>
        l4 l5 && (L.L.uchill_integration__cp_passenger_ac) &&
        {if}
' <r3> = <Cabinair_Temp>
' automatic temperature selection--driver has no influence
            l3 (C.L.ac_cooling_cabin_t_min) >
            {if}
                (C.L.ac_cooling_output_t_min) s0
            {else}
                (C.L.ac_heating_output_t_max) s0
            {endif}
' sanity-check
            (M.L.ac_available) (L.L._r8)
            {if}
' pass; A/C is to be activated
' check if eco mode applies
                (M.L.ac_eco_mode_available) (L.L._r8)
                {if}
' A/C is to be activated in eco mode; but still, don't allow the actual output temp to be cooler than <r0>, when
'  cooling, or warmer than <r0>, when heating
                l3 (C.L.ac_cooling_cabin_t_min) >
                {if}
                    l6 l0 max s2
                {else}
                    l6 l0 min s2
                {endif}
' indicate that <actualize_passenger_ac_status> may begin, if it hasn't already, attempting to start the A/C
                    2 s1
                {else}
' A/C is to be activated in normal mode
' increase or decrease actual respective cooling or heating output temp, based on its difference from current cabin or
'  env temp, depending on whether recirculation or fresh mode is respectively in effect
                    l0 (C.L.ac_cooling_cabin_t_min) >
                    {if}
                        (C.L.ac_cooling_loss_per_degree) s7
                    {else}
                        (C.L.ac_heating_loss_per_degree) s7
                    {endif}
                    (L.L.uchill_integration__cp_air_circulation)
                    {if}
                        l3 l0 - (S.L._r8)
                    {else}
                        l6 l0 - (S.L._r8)
                    {endif}
                    l0 (L.L._r8) l7 * + s2
' don't allow the A/C to start when the cabin heaters are running and it is very cold; the A/C will be unable to
'  "compete" with the cabin heaters and severely reduce their effectiveness otherwise
                    (L.L.cabin_heaters_running) l2 (C.L.ac_heating_cabin_t_max) <= &&
                    {if}
                        0 s1
                        l3 s2
                    {else}
' indicate that <actualize_passenger_ac_status> may begin, if it hasn't already, attempting to start the A/C
                        1 s1
                    {endif}
                {endif}
' only update the output temp if <actualize_passenger_ac_status> has actually activated the A/C; else wait, using the
'  current cabin temperature instead
                (L.L.passenger_ac_running)
                {if}
                    l2 s0
                {else}
' wait, using the current cabin temperature instead
                    l3 s0
                {endif}
            {else}
' fail; A/C will be / stay deactivated
                l3 s0 s2
                0 s1
            {endif}
        {else}
' no power; stay / become deactivated
            l3 s0 s2
            0 s1
        {endif}
    {else}
' no passenger A/C unit available at all; stay / become deactivated
        l3 s0 s2
        0 s1
    {endif}
    l0 (S.L.passenger_ac_t_target)
    l1 (S.L.passenger_ac_running_target)
    l2 (S.L.passenger_ac_t_target_preview)
' gradual update
    (M.L.actualize_passenger_ac_output_air_temp)
{end}

' Actually (de-)activates the passengers' A/C.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_passenger_ac_status}
' this is determined via <calculate_passenger_ac_temps>
    (L.L.passenger_ac_running_target) s2
    {if}
' activation branch
' new start condition (cached for duplication reduction)
' <ac_cooldown_threshold_t_diff> contributes to an "anti-repeat" condition, so as to prevent instantaneous on-off loops
' <r3> = <Cabinair_Temp>
        l3 (C.L.ac_heating_cabin_t_max) (C.L.ac_cooldown_threshold_t_diff) s0 - < l3 (C.L.ac_cooling_cabin_t_min) l0 + >
            || s7
        (L.L.passenger_ac_running) 1 = (L.L.driver_ac_running) 1 = (L.L.ac_humidity_management_active) || l7 && ||
        {if}
' no delay if passengers' A/C or some other A/C-based function already active; activate (/ resume)
            0 s0
            -1 s1
        {else}
' start anew
            (L.L.passenger_ac_start_stop_delay) s1 -1 =
            {if}
                (C.L.passenger_ac_start_delay_additional_max) random (C.L.passenger_ac_start_delay_min) + s1
                l2 1 =
                {if}
' increase delay based on env-to-target difference (doesn't apply to eco mode)
                    l6 (L.L.passenger_ac_t_target_preview) - abs (C.L.passenger_ac_start_delay_env_factor) * l1 + s1
                {endif}
            {endif}
' <_r9> = <Timegap>
            (L.L.passenger_ac_start_stop_timer) (L.L._r9) + s0 l1 > l7 &&
            {if}
' actually activate
                0 s0
                -1 s1
            {else}
' no change; inactive and stays inactive
                (L.L.passenger_ac_running) s2
            {endif}
        {endif}
    {else}
' deactivation branch
        (L.L.passenger_ac_running) s2
        {if}
            (L.L.passenger_ac_start_stop_delay) s1 -1 =
            {if}
                (C.L.passenger_ac_stop_delay_additional_max) random (C.L.passenger_ac_stop_delay_min) + s1
            {endif}
' deactivation condition: either direct and _delayed_ (timer-based, when e.g. power is lost or function is switched off
'  by user), or indirect and _instant_ (target cabin temp achieved)
            (L.L.passenger_ac_start_stop_timer) (L.L._r9) + s0 l1 > l4 l5 && l3 (C.L.ac_heating_cabin_t_max) >= &&
                l3 (C.L.ac_cooling_cabin_t_min) <= && ||
            {if}
' actually deactivate
                0 s0 s2
                -1 s1
' else: no change; active and stays active
            {endif}
        {else}
' no change; inactive and stays inactive
            0 s0
            -1 s1
        {endif}
    {endif}
    l0 (S.L.passenger_ac_start_stop_timer)
    l1 (S.L.passenger_ac_start_stop_delay)
' prevent <passenger_ac_running> from becoming 1 iff <passenger_ac_t> not (yet) in comfort levels
    (L.L.passenger_ac_t) s0 (L.L.passenger_ac_t_target_preview) s1 (M.L.ac_t_comfortable) l2 (S.L.passenger_ac_running)
{end}

' (De-)activates the automatic humidity management function, which is, in turn, controlled by the A/C-based humidity
' management function, the status of which is controlled through <actualize_ac_humidity_management_status>.
' Auto-(de)humidification gets activated when a) the vehicle has passenger air-conditioning _and_ b) either or both of
' the driver's and/or passengers' A/C functions have been requested (they need _not_ necessarily be in a _running_
' state), _and_ c) power is sufficient (implying both engine and electrics), _and_ d) the cabin's humidity
' level exceeds <ac_auto_humidity_management_dehumidification_start_rel_cabin_humidity_max>, or is less than
' <ac_auto_humidity_management_humidification_start_rel_cabin_humidity_min>.
'
' When auto humidity management is active and <uchill_integration__cp_humidity_management> has not been pushed, the
' corresponding button's LED blinks.
'
' Note: This macro doesn't employ the timer-based structure of the previous similar ones, because, as already mentioned,
' there's a separate macro--<actualize_ac_humidity_management_status>--in place for that purpose.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_auto_humidity_management_status}
    (L.L.Cabinair_relHum) s0
' <r4> = <uchill_integration__electrics_on>
' <r5> = <uchill_integration__engine_running>
    l4 l5 &&
    {if}
        (L.L.uchill_integration__passenger_ac_installed) (L.L.uchill_integration__cp_driver_ac)
            (L.L.uchill_integration__cp_passenger_ac) || && s1 l0
            (C.L.ac_auto_humidity_management_dehumidification_start_rel_cabin_humidity_max) > l0
            (C.L.ac_auto_humidity_management_humidification_start_rel_cabin_humidity_min) < || &&
        {if}
            1 s7
        {else}
            l1 ! (L.L.ac_auto_humidity_management_active) s7
                l0 (C.L.ac_auto_humidity_management_dehumidification_stop_rel_cabin_humidity_min) <=
                l0 (C.L.ac_auto_humidity_management_humidification_stop_rel_cabin_humidity_max) >=
                && && ||
            {if}
                0 s7
            {endif}
        {endif}
    {else}
        0 s7
    {endif}
    l7 (S.L.ac_auto_humidity_management_active)
{end}

' Controls A/C-based (de)humidification, which comprises both the automatic (see
' <actualize_auto_dehumidification_status>) and the "manual" humidity management
' (triggered by <uchill_integration__cp_humidity_management>) function. Both
' in-/de-crement humidity at the exact same rate, but their min/max
' thresholds differ.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_ac_humidity_management_status}
' <r3> = <Cabinair_Temp>
' <r4> = <uchill_integration__electrics_on>
' <r5> = <uchill_integration__engine_running>
' <r6> = <Weather_Temperature>
    (L.L.Cabinair_relHum) s7
    l4 l5 && l6 (C.L.ac_env_t_min) s0 > && l6 (C.L.ac_env_t_max) s1 < && l3 l0 > && l3 l1 < &&
        (L.L.uchill_integration__passenger_ac_installed) && (L.L.ac_auto_humidity_management_active)
        (L.L.uchill_integration__cp_humidity_management) || && l7 (C.L.dehumidification_rel_cabin_humidity_min) > l7
        (C.L.humidification_rel_cabin_humidity_max) < || &&
    {if}
' activation branch
' new start condition (cached for duplication reduction)
' <humidity_management_cooldown_threshold_humidity_diff> contributes to an "anti-repeat" condition, so as to prevent
'  instantaneous on-off loops
        l7 (C.L.dehumidification_rel_cabin_humidity_min)
            (C.L.humidity_management_cooldown_threshold_humidity_diff) + >
            (L.L.Cabinair_relHum) (C.L.humidification_rel_cabin_humidity_max)
            (C.L.humidity_management_cooldown_threshold_humidity_diff) - <
            || (S.L._r8)
        (L.L.ac_humidity_management_active) (L.L.driver_ac_running) 1 = (L.L.passenger_ac_running) 1 = || (L.L._r8) && ||
        {if}
' no delay if humidity management or some other A/C-based function already active; activate (/ resume)
            0 s0
            -1 s1
            1 s2
        {else}
' start anew
            (L.L.ac_humidity_management_start_stop_delay) s1 -1 =
            {if}
                (C.L.ac_humidity_management_start_delay_additional_max) random
                    (C.L.ac_humidity_management_start_delay_min) + s1
' increase delay based on current cabin humidity (or lack thereof)
                l7 (C.L.dehumidification_rel_cabin_humidity_min) >
                {if}
                    (L.L.Cabinair_absHum) (C.L.ac_humidity_management_start_delay_env_factor) * l1 + s1
                {else}
                    l3 (F.L.saturation_humidity_f_temp) (L.L.Cabinair_absHum) - 0 max
                        (C.L.ac_humidity_management_start_delay_env_factor) * l1 + s1
                {endif}
            {endif}
' <_r9> = <Timegap>
            (L.L.ac_humidity_management_start_stop_timer) (L.L._r9) + s0 l1 > (L.L._r8) &&
            {if}
' actually activate
                0 s0
                -1 s1
                1 s2
            {else}
' no change; inactive and stays inactive
                0 s2
            {endif}
        {endif}
    {else}
' deactivation branch
        (L.L.ac_humidity_management_active)
        {if}
            (L.L.ac_humidity_management_start_stop_delay) s1 -1 =
            {if}
                (C.L.ac_humidity_management_stop_delay_additional_max) random (C.L.ac_humidity_management_stop_delay_min) + s1
            {endif}
' deactivation condition: either direct and _delayed_ (timer-based, when e.g. power is lost or all related functions
'  are switched off by user), or indirect and _instant_ (target cabin level of humidity achieved)
            (L.L.ac_humidity_management_start_stop_timer) (L.L._r9) + s0 l1 > l4 l5 && l7
                (C.L.dehumidification_rel_cabin_humidity_min) <= && l7
                (C.L.humidification_rel_cabin_humidity_max) >= && ||
            {if}
' actually deactivate
                0 s0 s2
                -1 s1
            {else}
' no change; active and stays active
                1 s2
            {endif}
        {else}
' no change; inactive and stays inactive
            0 s0 s2
            -1 s1
        {endif}
    {endif}
    l0 (S.L.ac_humidity_management_start_stop_timer)
    l1 (S.L.ac_humidity_management_start_stop_delay)
    l2 (S.L.ac_humidity_management_active)
{end}

' Determines the cabin heaters' output temperature.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_cabin_heater_temps}
    (L.L.uchill_integration__passenger_ac_installed) s7
    (L.L.uchill_integration__cp_cabin_heaters) (S.L._r8)
' <r3> = <Cabinair_Temp>
    l3 (C.L.cabin_heater_cabin_t_max) < (S.L._r11)  
' <r4> = <uchill_integration__electrics_on>
' <r5> = <uchill_integration__engine_running>
    l4 l5 && l7 (L.L._r8) && (L.L._r11) && l7 ! (L.L._r8) (L.L._r11) && (L.L.uchill_integration__cp_humidity_management)
        (L.L._r11) && (L.L.Cabinair_relHum) (C.L.dehumidification_rel_cabin_humidity_min) > && || && || &&
        (L.L.uchill_integration__engine_t) (C.L.cabin_heater_engine_t_min) > &&
    {if}
        (L.L.cabin_heaters_running)
        {if}
            (L.L.uchill_integration__engine_t) (C.L.heat_exchanger_effectiveness) * s0
        {else}
            l3 s0
        {endif}
        1 s1
    {else}
        l3 s0
        0 s1
    {endif}
    l0 (S.L.cabin_heater_t_target)
    l1 (S.L.cabin_heaters_running_target)
' gradual update
    (M.L.actualize_cabin_heater_output_air_temp)
{end}

' Controls the cabin heaters' status. If the vehicle offers no passenger air-conditioning,
' <uchill_integration__cp_humidity_management> triggers the cabin heaters as well, in which case their operation is
' constrained both by maximum cabin temperature, as well as by minimum cabin humidity--whichever condition's
' complement gets satisfied first.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_cabin_heater_status}
    (L.L.uchill_integration__passenger_ac_installed) s7
    (L.L.uchill_integration__cp_cabin_heaters) (S.L._r8)
    (L.L.uchill_integration__cp_humidity_management) (S.L._r10)
    (L.L.cabin_heaters_running_target)
    {if}
' activation branch
        (L.L.cabin_heaters_running)
        {if}
' already active; resume
            0 s0
            -1 s1
            1 s2
        {else}
' start anew
            (L.L.cabin_heaters_start_stop_delay) s1 -1 =
            {if}
' increase delay based on engine temp
                (C.L.cabin_heater_start_delay_additional_max) random (C.L.cabin_heater_engine_t_normal)
                    (L.L.uchill_integration__engine_t) - 0 max (C.L.cabin_heater_start_delay_env_factor) * +
                    (C.L.cabin_heater_start_delay_min) + s1
            {endif}
' <cabin_heater_cooldown_threshold_t_diff> and <humidity_management_cooldown_threshold_humidity_diff> contribute to
'  "anti-repeat" conditions, so as to prevent instantaneous on-off loops
' <r3> = <Cabinair_Temp>
            l3 (C.L.cabin_heater_cabin_t_max) (C.L.cabin_heater_cooldown_threshold_t_diff) - < (S.L._r11)
            (L.L.Cabinair_relHum) (C.L.dehumidification_rel_cabin_humidity_min)
                (C.L.humidity_management_cooldown_threshold_humidity_diff) + > (S.L._r12)
' <_r9> = <Timegap>
            (L.L.cabin_heaters_start_stop_timer) (L.L._r9) + s0 l1 > l7 (L.L._r8) && (L.L._r11) && l7 ! (L.L._r8)
                (L.L._r11) && (L.L._r10) (L.L._r11) && (L.L._r12) && || && || &&
            {if}
' actually activate
                0 s0
                -1 s1
                1 s2
            {else}
' no change; inactive and stays inactive
                0 s2
            {endif}
        {endif}
    {else}
' deactivation branch
        (L.L.cabin_heaters_running)
        {if}
            (L.L.cabin_heaters_start_stop_delay) s1 -1 =
            {if}
                (C.L.cabin_heater_stop_delay_additional_max) random (C.L.cabin_heater_stop_delay_min) + s1
            {endif}
' deactivation condition: either direct and _delayed_ (timer-based, when e.g. power is lost or all relevant functions
'  are switched off by user), or indirect and _instant_ (target cabin temp and/or level of humidity achieved)
            l3 (C.L.cabin_heater_cabin_t_max) >= (S.L._r11)
            (L.L.Cabinair_relHum) (C.L.dehumidification_rel_cabin_humidity_min) <= (S.L._r12)
' <r4> = <uchill_integration__electrics_on>
' <r5> = <uchill_integration__engine_running>
            (L.L.cabin_heaters_start_stop_timer) (L.L._r9) + s0 l1 > l4 l5 && (L.L._r13) && l7 (L.L._r8) && (L.L._r11) &&
                l7 ! (L.L._r8) (L.L._r11) && (L.L._r10) (L.L._r11) (L.L._r12) || && || && || && ||
            {if}
' actually deactivate
                0 s0 s2
                -1 s1
            {else}
' no change; active and stays active
                1 s2
            {endif}
        {else}
' no change; inactive and stays inactive
            0 s0 s2
            -1 s1
        {endif}
    {endif}
    l0 (S.L.cabin_heaters_start_stop_timer)
    l1 (S.L.cabin_heaters_start_stop_delay)
    l2 (S.L.cabin_heaters_running)
' only relevant for <uchill_integration__cp_humidity_management_led> set in <actualize_panel_leds>; the latter has to
'  be able to distinguish between temperature-constrained
'  (<uchill_integration__cp_cabin_heaters> == 1)
'  and temperature- _and_ humidity-constrained cabin heater operation
'  ((<uchill_integration__cp_cabin_heaters> == 0) && (<uchill_integration__cp_humidity_management> == 1))
'  in vehicles without passenger air-conditioning, for aesthetics' sake.
    l2 l7 ! && (L.L._r10) && (L.L.Cabinair_relHum) (C.L.dehumidification_rel_cabin_humidity_min) > &&
        (S.L.cabin_heater_dehumidification_active)
{end}

' Controls the auxiliary heating's status.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_auxheat_status}
' <r4> = <uchill_integration__electrics_on>
    l4 (L.L.uchill_integration__cp_auxheat) && (L.L.uchill_integration__engine_t) (C.L.auxheat_engine_t_max) < &&
    {if}
' activation branch
        (L.L.auxheat_active)
        {if}
' already active; resume
            0 s0
            -1 s1
            1 s2
        {else}
' start anew
            (L.L.auxheat_start_stop_delay) s1 -1 =
            {if}
' increase delay based on engine temp
                (C.L.auxheat_start_delay_additional_max) random (C.L.auxheat_engine_t_normal)
                    (L.L.uchill_integration__engine_t) - 0 max
                    (C.L.auxheat_start_delay_env_factor) * +
                    (C.L.auxheat_start_delay_min) + s1
            {endif}
' <auxheat_cooldown_threshold_t_diff> contributes to an "anti-repeat" condition, so as to prevent instantaneous on-off
'  loops
' <_r9> = <Timegap>
            (L.L.auxheat_start_stop_timer) (L.L._r9) + s0 l1 > (L.L.uchill_integration__engine_t)
                (C.L.auxheat_engine_t_max) (C.L.auxheat_cooldown_threshold_t_diff) - < &&
            {if}
' actually activate
                0 s0
                -1 s1
                1 s2
            {else}
' no change; inactive and stays inactive
                0 s2
            {endif}
        {endif}
    {else}
' deactivation branch
        (L.L.auxheat_active)
        {if}
            (L.L.auxheat_start_stop_delay) s1 -1 =
            {if}
                (C.L.auxheat_stop_delay_additional_max) random (C.L.auxheat_stop_delay_min) + s1
            {endif}
' deactivation condition: either direct and _delayed_ (timer-based, when e.g. power is lost or function is switched off
'  by user), or indirect and _instant_ (target engine temp achieved)
            (L.L.auxheat_start_stop_timer) (L.L._r9) + s0 l1 > l4 (L.L.uchill_integration__engine_t)
                (C.L.auxheat_engine_t_max) >= && ||
            {if}
' actually deactivate
                0 s0 s2
                -1 s1
            {else}
' no change; active and stays active
                1 s2
            {endif}
        {else}
' no change; inactive and stays inactive
            0 s0 s2
            -1 s1
        {endif}
    {endif}
    l0 (S.L.auxheat_start_stop_timer)
    l1 (S.L.auxheat_start_stop_delay)
    l2 (S.L.auxheat_active)
{end}

' Computes the air volume inserted into the cabin by the driver's A/C.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_driver_ac_air_exchange_volumes}
    (C.L.cabinair_A_driver_ac) s7
    (L.L.uchill_integration__cp_driver_ac_fan) s0
' recirculation mode
    (L.L.uchill_integration__cp_air_circulation) s1 (L.L.uchill_integration__cp_driver_ac) s2 ||
    {if}
        l1
        {if}
            (C.L.driver_ac_recirculation_mode_effectiveness) (S.L._r10)
        {else}
            (C.L.driver_ac_effectiveness) (S.L._r10)
        {endif}
' <r4> = <uchill_integration__electrics_on>
        l4
        {if}
' <r5> = <uchill_integration__engine_running>
            l5 !
            {if}
                l0 (C.L.driver_ac_engine_off_air_volume_factor) min s0    
            {else}
                l2
                {if}
                    (L.L.driver_ac_running) s2 !
                    {if}
                        l0 (C.L.driver_ac_idle_air_volume_factor) min s0
                    {else}
                        l2 -1 =
                        {if}
' A/C currently in the process of pre-cooling/-heating; no air flow permitted
                            0 s0
                        {endif}
                    {endif}
                {endif}
            {endif}
            l7 l0 * (L.L._r10) * s0
        {else}
' no powerless air flow permitted in recirculation mode
            0 s0
        {endif}
        l0 s1
        {if}
' humidity equals the product of <r7>, <_r10>, unless recirculation and/or humidity management is active, in which
'  case it gets "magically" decreased to just a fraction thereof, to allow humidity management to cope
            l7 s1
            (L.L.uchill_integration__cp_air_circulation) (L.L.ac_humidity_management_active) ||
            {if}
                l1 (C.L.driver_ac_humidity_relevant_air_volume_recycling_factor) * s1
            {endif}
        {endif}
        l7 (L.L._r10) * (S.L._r8)
    {else}
' fresh-air mode
        l7 (L.L.velocity) 20 / abs (C.L.cabinair_openable_surface_convection_minkmh) +
            (C.L.cabinair_openable_surface_convection_effectiveness) * 3.6 / * s7 (S.L._r8)
        l4
        {if}
            l5 !
            {if}
                l0 (C.L.driver_ac_engine_off_air_volume_factor) min s0
            {endif}
        {else}
             0 s0
        {endif}
' humidity equal to temp-relevant air flow
        l0 (C.L.driver_ac_powerless_non_recirculated_air_volume_factor) max l7 * s0 s1
    {endif}
    l0 (S.L.cabinair_Vrate_driver_ac_target)
    l1 (S.L.cabinair_Vrate_driver_ac_humidity)
    (L.L._r8) (S.L.cabinair_Vrate_driver_ac_max)
' gradual update
    (M.L.actualize_driver_ac_temp_relevant_air_exchange_volume)
{end}

' Computes the air volume inserted into the cabin by the passengers' A/C.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_passenger_ac_air_exchange_volumes}
    (L.L.uchill_integration__cp_air_circulation)
    {if}
        (C.L.passenger_ac_recirculation_mode_effectiveness) s1
    {else}
        (C.L.passenger_ac_effectiveness) s1
    {endif}
    (C.L.cabinair_A_per_passenger_ac_unit) (L.L.uchill_integration__number_of_passenger_ac_units) * s7
' <r4> = <uchill_integration__electrics_on>
    (L.L.uchill_integration__passenger_ac_installed) l4 &&
    {if}
        (L.L.passenger_ac_running) s2 0 >
        {if}
            1 s0
        {else}
            (L.L.uchill_integration__cp_passenger_ac)
            {if}
' <r5> = <uchill_integration__engine_running>
                l5
                {if}
                    l2 !
                    {if}
                        (C.L.passenger_ac_idle_air_volume_factor) s0
                    {else}
                        l2 -1 =
                        {if}
' A/C currently in the process of pre-cooling/-heating; no air flow permitted
                            0 s0
                        {endif}
                    {endif}
                {else}
                    (C.L.passenger_ac_engine_off_air_volume_factor) s0
                {endif}
            {else}
                0 s0
            {endif}
        {endif}
        l0
        {if}
            l0 * l1 * l7 * s0
        {endif}
    {else}
        0 s0
    {endif}
    l0 (S.L.cabinair_Vrate_passenger_ac_target)
    {if}
        l7 s0
' humidity equals the product of <r1>, <r7>, unless recirculation and/or humidity management is active, in which
'  case it gets "magically" decreased to just a fraction thereof, to allow humidity management to cope
        (L.L.uchill_integration__cp_air_circulation) (L.L.ac_humidity_management_active) ||
        {if}
            l0 (C.L.passenger_ac_humidity_relevant_air_volume_recycling_factor) * s0
        {endif}
    {endif}
    l0 (S.L.cabinair_Vrate_passenger_ac_humidity)
    l1 l7 * (S.L.cabinair_Vrate_passenger_ac_max)
' gradual update
    (M.L.actualize_passenger_ac_temp_relevant_air_exchange_volume)
{end}

' Computes the air volume heated up by the cabin heaters.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_cabin_heater_air_exchange_volume}
    (C.L.cabinair_A_per_cabin_heater) (L.L.cabin_heaters_running) * (L.L.uchill_integration__number_of_cabin_heaters) * s0
    (L.L.auxheat_active) l6 (C.L.cabin_heater_turbo_mode_env_t_max) < (L.L.uchill_integration__engine_t)
        (C.L.cabin_heater_turbo_mode_engine_t_max) < || &&
    {if}
        l0 (C.L.cabin_heater_turbo_mode_effectiveness_increase_factor) * s0
    {endif}
    l0 (C.L.cabin_heater_effectiveness) * (S.L.cabinair_Vrate_cabin_heater_target)
' gradual update
    (M.L.actualize_cabin_heater_air_exchange_volume)
    (C.L.cabinair_A_per_cabin_heater) (C.L.cabin_heater_turbo_mode_effectiveness_increase_factor) *
        (L.L.uchill_integration__number_of_cabin_heaters) * (C.L.cabin_heater_effectiveness) *
        (S.L.cabinair_Vrate_cabin_heater_max)
{end}

' Simulates the greenhouse effect occurring in the vehicle's cabin due to insolation.
'
' Disclaimer: None of this is claimed to be scientifically sane, let alone correct.
'
' Strategy: Calculating the actual infrared energy that gets "trapped" in the cabin at least remotely accurately is
' tricky, as it depends on a gazillion factors. In this implementation, as an alternative to employing a scientific-ish
' approach, we hack our way from the end towards the beginning, assuming that the _maximum_ temperature increase rate
' (maximum insolation, no convective heat loss due to open windows, hatches, and doors) is already known, linear, and
' equal to
'     <ghe_t_increase_rate_max> (1),
'         during a period of
'     <ghe_time_max> seconds.
' The actual values are premised on related findings of studies conducted on cars.
' In order to compute the temperature rate within the current context, we next use (1) with the (101% arbitrary)
' formula
'     (current (net) ghe temperature rate) = (1) * (insolation factor) * (radiation containment factor)
'         * (A/C pseudo-factor) (2)
' where
'     (insolation factor) = min((solar elevation angle parameter), (brightness parameter), (precipitation parameter)),
'         all of whe parameters of which are derived from OMSI-built-in variables
'     (radiation containment factor) expresses greenhouse effect reduction, occurring due to radiative heat "escape"
'         (through windows, etc.); not to be confused with convective losses (that too are linked to open surfaces)
'     (A/C pseudo-factor) is just a hack to ensure the driver and passenger A/C-based functions are able to, when in
'         cooling mode, mitigate the greenhouse effect-induced heat
' Finally, we calculate a bounded variant of (2) that also accounts for (the primary amongst) the vehicle's current
' heat losses, as well as the maximum permitted ghe-induced temperature increase
'     (current (gross) ghe temperature rate) = min(((2) + (current loss rate)), (maximum loss rate)) (3),
' where
'     (current loss rate) = abs(min(0, ((conductive losses) + (convective losses) + (A/C cooling mode losses)), and
'     (maximum loss rate) = the same kinds of losses as above, but computed for a environment - cabin temperature
'         difference equal to (2)
' By doing so, we ensure that a) the cabin's temperature does actually increase at a rate of (at most) (2), but b)
' without exceeding the upper bound of <Weather_Temperature> + (2).
' (2), (3) are, lastly, persisted as <cabinair_Qrate_ghe_net>, <cabinair_Qrate_ghe_gross>, respectively, and, upon this
' macro's return, <cabinair_Qrate_ghe_gross> is treated by the delegator as any other <cabinair_Qrate_xxx> variable,
' during cabin temperature update.
'-----------------------------------------------------------------------------------------------------------------------
{macro:ghe_impact}
' general notes:
' - the upper and lower bounds we sanitize the "built-in" OMSI vars (<SunAlt>, etc.) against are _not_ redundant,
'  because OMSI tends to (sneakily) assign "special-case" out-of-bounds values to them at times; e.g. <PrecipRate>
'  might actually be negative in cases when it should normally be 0 according to the OMSI documentation
' - we record the individual sub-products / factors purely for debugging purposes

' ghe insolation factor
' ideally we would also somehow add the vehicle's orientation as a function of the sun's position into the "equation";
'  i.e., the (glass) surface exposed to the sun's rays, max at a right angle

' insolation factor - solar elevation angle parameter
    (L.S.SunAlt) 0 max 90 min (F.L.ghe_insolation_factor_max_f_solar_elevation_angle)
    (S.L.ghe_insolation_factor_solar_elevation_angle_param)

' insolation factor - environmental brightness parameter
' notes:
' - this is erroneous to some extent, because light sources _other_ than the sun (i.e., street lights) affect
'  <Envir_Brightness> as well
' - OMSI exposes neither the sun's "brightness" per se, nor the state of night-time light sources (<NightLightA> is
'  only made available to scenery objects)
' - a proper workaround would be to sample <Envir_Brightness> and/or calculate an average
        (L.L.Envir_Brightness) 0 max 1 min (S.L.ghe_insolation_factor_env_brightness_param) min

' insolation factor - precipitation parameter (perhaps we should take humidity into account as well?)
        1 (L.L.PrecipRate) 0 max 1 min (C.L.ghe_insolation_factor_precipitation_param_max_reduction) min -
        (S.L.ghe_insolation_factor_precipitation_param) min

' insolation factor - overall
        (S.L.ghe_insolation_factor)

' ghe radiation containment factor (is this actually negligibly small irl?)
        1 (L.L.cabinair_A_open_surfaces) (L.L.cabinair_A_openable_surfaces) /
        (C.L.ghe_containment_factor_max_reduction) min - (S.L.ghe_containment_factor) *

' ghe A/C pseudo-factor

        1
' A/C factor - driver A/C parameter
        (L.L.driver_ac_running) 0 > (C.L.ghe_ac_factor_driver_ac_param) *

' A/C factor - passenger A/C parameter
        (L.L.passenger_ac_running) 0 > (C.L.ghe_ac_factor_passenger_ac_param) * +

' A/C factor - overall
        (L.L.Cabinair_Temp) (C.L.ac_cooling_cabin_t_min) > * (C.L.ghe_ac_factor_max_reduction) min -
        (S.L.ghe_ac_factor) *

' overall ghe intensity
    (S.L.ghe_intensity)

' finally calculate the greenhouse-induced temperature increase rate
        (C.L.ghe_t_increase_rate_max) * s0 s1
    {if}
' note that the rates calculated below are per second, rather than per frame, since <cabinair_frame> handles the
'  conversion after <ghe_impact>'s return

' <r1> = current loss rate
        (L.L.cabinair_Qrate_env_conduction) (C.L.cabinair_cvm) / /-/ (C.L.ghe_env_conduction_resistance_factor) *
            (L.L.cabinair_Qrate_env_convection) (C.L.ghe_env_convection_resistance_factor) * + s1
        (L.L.cabinair_Qrate_driver_ac) s7

' <r2> = max loss rate
        l0 (L.L.ghe_env_conduction_resistance_const) * l0 (L.L.ghe_env_convection_resistance_const) *
            (L.L.cabinair_Vrate_open_surfaces) * + l0 (L.L.ghe_ac_resistance_const) * (L.L.cabinair_Vrate_driver_ac) *
            + s2

' ...plus losses due to passenger A/C, if applicable
        (L.L.uchill_integration__passenger_ac_installed)
        {if}
            l7 (L.L.cabinair_Qrate_passenger_ac) + s7
            l2 l0 (L.L.ghe_ac_resistance_const) * (L.L.cabinair_Vrate_passenger_ac) * + s2
        {endif}     
        l1 l7 (C.L.ghe_ac_resistance_factor) * + s1

' (<r0> + <r1>) -> <r2>
        l0 l1 0 min abs + l2 min s1
    {endif}

' assign results; note that <ghe_t_target>, <ghe_t_increase_target> are by no means meant to serve as a "prediction" of
' the vehicle's final temperature
    l0 (S.L.cabinair_Qrate_ghe_net) (C.L.ghe_time_max) * (S.L.ghe_t_increase_target) (L.S.Weather_Temperature) +
        (S.L.ghe_t_target)
    l1 (S.L.cabinair_Qrate_ghe_gross)
{end}

' Computes the degree of cabin window misting on the interior side. Cabin windows mist on the inside when the cabin is
' sufficiently humid, and the environment is sufficiently cold--colder than the dew point of the cabin, specifically.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_cabin_window_int_misting_degree}
' <r0> = <Cabinair_Temp>
' <_r8> = <Cabinair_relHum>
    l0 (S.L._r10) (L.L._r8) (S.L._r9) (M.L.calculate_cabin_window_misting_degree)
    (L.L._r11) (S.L.cabin_window_int_misting_target)
    (L.L._r13) (S.L.cabin_dew_point)
' gradual update
    (M.L.actualize_cabin_window_int_misting_degree)
{end}

' Computes the degree of cabin window misting on the exterior side. Cabin windows mist on the outside when the
' environment is sufficiently humid, and the cabin is sufficiently cold--colder than the dew point of the
' environment, specifically.
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_cabin_window_ext_misting_degree}
' compute relative env humidity first (OMSI already knows this, but keeps it a secret)
' <r6> = <Weather_Temperature>
' <r7> = <Weather_AbsHum>
    l7 l6 (S.L._r10) (F.L.saturation_humidity_f_temp) / (S.L.env_rel_humidity) (S.L._r9)
        (M.L.calculate_cabin_window_misting_degree)
    (L.L._r11) (S.L.cabin_window_ext_misting_target)
    (L.L._r13) (S.L.env_dew_point)
' gradual update
    (M.L.actualize_cabin_window_ext_misting_degree)
{end}

'----------------------------------------------
'    <calculate_driver_ac_temps> delegates
'----------------------------------------------

' Gradually in-/de-crements <driver_ac_t> by <ac_t_out_xxx_update_rate> (depending on whether the A/C is
' currently starting up normally, or is in eco mode or shutting down), until it reaches
' <driver_ac_t_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_driver_ac_output_air_temp}
' slow start-up - fast shut-down; fast rate applies to eco mode in either case
    (L.L.driver_ac_running) abs 1 =
    {if}
        (C.L.ac_t_out_slow_update_rate) s7
    {else}
        (C.L.ac_t_out_fast_update_rate) s7
    {endif}
    (L.L.driver_ac_t) (S.L._r10) (L.L.driver_ac_t_target) (S.L._r11) l7 (S.L._r12) (M.L.from_r10_to_r11_at_r12_linear)
        (L.L._r10) (S.L.driver_ac_t)
{end}

'-------------------------------------------------
'    <calculate_passenger_ac_temps> delegates
'-------------------------------------------------

' Gradually in-/de-crements <passenger_ac_t> by <ac_t_out_xxx_update_rate> (depending on whether the A/C is
' currently starting up normally, or is in eco mode or shutting down), until it reaches
' <passenger_ac_t_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_passenger_ac_output_air_temp}
' slow start-up - fast shut-down; fast rate applies to eco mode in either case
    (L.L.passenger_ac_running) abs 1 =
    {if}
        (C.L.ac_t_out_slow_update_rate) s7
    {else}
        (C.L.ac_t_out_fast_update_rate) s7
    {endif}
    (L.L.passenger_ac_t) (S.L._r10) (L.L.passenger_ac_t_target) (S.L._r11) l7 (S.L._r12)
        (M.L.from_r10_to_r11_at_r12_linear) (L.L._r10) (S.L.passenger_ac_t)
{end}

'-------------------------------------------------
'    <calculate_cabin_heater_temps> delegates
'-------------------------------------------------

' Gradually in-/de-crements <cabin_heater_t> by cabin_heater_t_out_xxx_update_rate> (depending on whether the cabin
' heaters are currently starting up or stopping), until it reaches <cabin_heater_t_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_cabin_heater_output_air_temp}
' fast start-up - fast shut-down initially, until <cabin_heater_t> is reasonably reduced, then slow; the latter
'  reflects the heaters' "post-deactivation radiation" effect
    (L.L.cabin_heaters_running) d ! (L.L.cabin_heater_t) (C.L.cabin_heater_idle_t_out_max) > && ||
    {if}
        (C.L.cabin_heater_t_out_fast_update_rate) s7
    {else}
        (C.L.cabin_heater_t_out_slow_update_rate) s7
    {endif}
    (L.L.cabin_heater_t) (S.L._r10) (L.L.cabin_heater_t_target) (S.L._r11) l7 (S.L._r12)
        (M.L.from_r10_to_r11_at_r12_linear) (L.L._r10) (S.L.cabin_heater_t)
{end}

'-------------------------------------------------------------
'    <calculate_driver_ac_air_exchange_volumes> delegates
'-------------------------------------------------------------

' Gradually in-/de-crements <cabinair_Vrate_driver_ac> by <driver_ac_temp_relevant_air_volume_update_rate>, until it
' reaches <cabinair_Vrate_driver_ac_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_driver_ac_temp_relevant_air_exchange_volume}
    (L.L.cabinair_Vrate_driver_ac) (S.L._r10) (L.L.cabinair_Vrate_driver_ac_target) (S.L._r11)
        (C.L.driver_ac_temp_relevant_air_volume_update_rate) (S.L._r12)
        (M.L.from_r10_to_r11_at_r12_linear) (L.L._r10)
        (S.L.cabinair_Vrate_driver_ac)
{end}

'----------------------------------------------------------------
'    <calculate_passenger_ac_air_exchange_volumes> delegates
'----------------------------------------------------------------

' Gradually in-/de-crements <cabinair_Vrate_passenger_ac> by <passenger_ac_temp_relevant_air_volume_update_rate>, until
' it reaches <cabinair_Vrate_passenger_ac_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_passenger_ac_temp_relevant_air_exchange_volume}
    (L.L.cabinair_Vrate_passenger_ac) (S.L._r10) (L.L.cabinair_Vrate_passenger_ac_target) (S.L._r11)
        (C.L.passenger_ac_temp_relevant_air_volume_update_rate) (S.L._r12)
        (M.L.from_r10_to_r11_at_r12_linear) (L.L._r10)
        (S.L.cabinair_Vrate_passenger_ac)
{end}

'---------------------------------------------------------------
'    <calculate_cabin_heater_air_exchange_volume> delegates
'---------------------------------------------------------------

' Gradually in-/de-crements <cabinair_Vrate_cabin_heater> by <cabin_heater_air_volume_xxx_update_rate> (depending on
' whether the cabin heaters are currently starting up or stopping), until it reaches
' <cabinair_Vrate_cabin_heater_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_cabin_heater_air_exchange_volume}
' fast start-up - slow shut-down
    (L.L.cabin_heaters_running)
    {if}
        (C.L.cabin_heater_air_volume_fast_update_rate) s7
    {else}
        (C.L.cabin_heater_air_volume_slow_update_rate) s7
    {endif}
    (L.L.cabinair_Vrate_cabin_heater) (S.L._r10) (L.L.cabinair_Vrate_cabin_heater_target) (S.L._r11) l7 (S.L._r12)
        (M.L.from_r10_to_r11_at_r12_linear) (L.L._r10) (S.L.cabinair_Vrate_cabin_heater)
{end}

'--------------------------------------------------------------
'    <calculate_cabin_window_int_misting_degree> delegates
'--------------------------------------------------------------

' Gradually in-/de-crements <cabin_window_int_misting> by <cabin_window_misting_update_rate>, until it reaches
' <cabin_window_int_misting_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_cabin_window_int_misting_degree}
    (L.L.cabin_window_int_misting) (S.L._r10) (L.L.cabin_window_int_misting_target) (S.L._r11)
        (C.L.cabin_window_misting_update_rate) (S.L._r12) (M.L.from_r10_to_r11_at_r12_linear)
        (L.L._r10) (S.L.cabin_window_int_misting)
{end}

'--------------------------------------------------------------
'    <calculate_cabin_window_ext_misting_degree> delegates
'--------------------------------------------------------------

' Gradually in-/de-crement <cabin_window_ext_misting> by <cabin_window_misting_update_rate>, until it reaches
' <cabin_window_ext_misting_target>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:actualize_cabin_window_ext_misting_degree}
    (L.L.cabin_window_ext_misting) (S.L._r10) (L.L.cabin_window_ext_misting_target) (S.L._r11)
        (C.L.cabin_window_misting_update_rate) (S.L._r12) (M.L.from_r10_to_r11_at_r12_linear)
        (L.L._r10) (S.L.cabin_window_ext_misting)
{end}

'--------------------------------------
'     shared delegates / utilities
'--------------------------------------

' Delegated to from <calculate_xxx_ac_temps> to check whether air-conditioning _can_ currently be activated. The value
' "returned" (as <_r8>) by this macro is true iff the environmental temperature is within reasonable bounds--such that
' the coolant would not solidify or evaporate--and the current cabin temperature is below or above the "ideal" cabin
' temperature range (expressed by the <ac_cooling_cabin_t_xxx> constants).
'-----------------------------------------------------------------------------------------------------------------------
{macro:ac_available}
' <r0> = non-final, i.e., ideal, value of <driver_ac_t_target> or <passenger_ac_t_target>, if air-conditioning actually
'  gets activated (in non-eco mode); the final value will in practice be higher or lower than that, when cooling or
'  heating, respectively
' <r3> = <Cabinair_Temp>
' <r6> = <Weather_Temperature>
    l6 (C.L.ac_env_t_min) > l6 (C.L.ac_env_t_max) < && l3 (C.L.ac_heating_cabin_t_max) < l0 l3 > &&
' as part of the cooling preconditions, we additionally have to ensure that the cabin heaters are _not_ the source of
'  the "excess" heat (i.e., causing <r3> to exceed <ac_cooling_cabin_t_min>), as cooling would otherwise be pointless
        l3 (C.L.ac_cooling_cabin_t_min) > l0 l3 < && (L.L.cabin_heaters_running) ! && (L.L.cabinair_Vrate_cabin_heater)
        ! && (L.L.uchill_integration__cp_cabin_heaters) ! && (L.L.uchill_integration__passenger_ac_installed) d !
        (L.L.uchill_integration__cp_humidity_management) ! && || && || && (S.L._r8)
{end}

' Delegated to from <calculate_xxx_ac_temps> after <ac_available> has yielded true, i.e., when air-conditioning is to
' be activated, to determine whether the economy-like cooling or heating is applicable (also known as "free"
' cooling / heating). This is the case when the cabin needs to be either _cooled_ and the environment is
' sufficiently _cooler_ than the former already, or when the former needs to be _heated_ and the latter
' happens to be _warmer_ than the former. If so, fresh air is used as the coolant agent. Practically
' speaking, this mode is equivalent to the A/C being off and fresh air being directly "pumped" into
' the cabin; unlike the latter case, however, temperature and humidity constraints are still
' enforced while in eco mode. The outcome is "returned" to the delegating macro via <_r8>.
'-----------------------------------------------------------------------------------------------------------------------
{macro:ac_eco_mode_available}
' <r0> = non-final, i.e., ideal, value of <driver_ac_t_target> or <passenger_ac_t_target>, if air-conditioning actually
'  gets activated (in non-eco mode); the final value will in practice be lower or higher than that, when heating or
'  cooling, respectively
' <r3> = <Cabinair_Temp>
' <r6> = <Weather_Temperature>
' about these constants:
' - <ac_eco_mode_xxx_env_t_target_t_diff_max> (C1) indicates how much cooler (when heating is desired) or warmer (when
'  cooling is desired) than <r0>, <r6> must _at most_ be
' - <ac_eco_mode_xxx_env_t_cabin_t_diff_min> (C2) indicates how much cooler (when cooling is desired) or warmer (when
'  heating is desired) than <r3>, <r6> must _at least_ be
' eco-heating-precondition:
'  <r6> > <r0> - C1
'  <r3> < <r6> - C2
' eco-cooling precondition:
'  <r6> < <r0> + C1
'  <r3> > <r6> + C2
' note that C2 must be sufficiently high in the cooling case, or the cooling effect is going to be very weak, thus
'  easily "overpowered" by the engine and greenhouse losses
    (L.L.uchill_integration__cp_air_circulation) ! l0 l3 > l6 l0 (C.L.ac_eco_mode_heating_env_t_target_t_diff_max) - >
        && l3 l6 (C.L.ac_eco_mode_heating_env_t_cabin_t_diff_min) - < && l0 l3 < l6 l0
        (C.L.ac_eco_mode_cooling_env_t_target_t_diff_max) + < && l3 l6 (C.L.ac_eco_mode_cooling_env_t_cabin_t_diff_min)
        + > && || && (S.L._r8)
{end}

' Delegated to from <actualize_xxx_ac_status> to determine, when <xxx_ac_running> is to be set to 1, if <xxx_ac_t> is
' "close enough"--as per the <ac_xxx_output_t_to_t_target_diff_max> constants--to <xxx_ac_t_preview>
' (<xxx_ac_t_target>, eventually) in order to be considered "comfortable".
'
' As an example, say that the cabin is to be cooled down from an initial temperature of 40 oC. The A/C, i.e., <calculate_xxx_ac_temps>,
' will start gradually decrementing <xxx_ac_t> towards <xxx_ac_t_target>. At first, however, <xxx_ac_t>, being of, say, 39.5 oC, even
' if indeed "capable of" cooling the cabin, would still perceived as uncomfortably high by humans. Thus, through this macro, the A/C
' is given some extra time to cool down (or heat up) adequately before actually inserting any air into the cabin. While in this
' intermediate state, the A/C's corresponding <xxx_ac_running> variable is set to -1.
'-----------------------------------------------------------------------------------------------------------------------
{macro:ac_t_comfortable}
' the following does _not_ apply to eco mode
' <r2> = <xxx_ac_t_running> (actual assignment takes place in the delegating macro, once this one has returned)
    l2 1 =
    {if}
' <r0> = <xxx_ac_t>
' <r1> = <xxx_ac_t_preview> (used instead of <xxx_ac_t_target> because <calculate_xxx_ac_temps> might not yet have had
'  a chance to set the latter)
' <r3> = <Cabinair_Temp>
        l1 l0 - abs s0
        l3 (C.L.ac_heating_cabin_t_max) < l0 (C.L.ac_heating_output_t_to_t_target_diff_max) >= && l3
            (C.L.ac_cooling_cabin_t_min) > l0 (C.L.ac_cooling_output_t_to_t_target_diff_max) >= &&
            ||
        {if}
            -1 s2
        {endif}
    {endif}
{end}

' Delegated to from <calculate_cabin_window_xxx_misting_degree> to compute the degree of cabin window (interior or
' exterior, accordingly) fogging.
'
' The macro initially checks whether there's enough humidity to begin with, by probing the relative (cabin or
' environmental) humidity value stored in <_r9>. It proceeds by estimating the minimum and, subsequently,
' actual dew point (which, despite being known to OMSI, is not exposed by it, and thus needs to be
' recalculated), given the (cabin or environmental) temperature stored in <_r10> and relative
' humidity. Lastly, it determines if <_r10>'s proximity to the dew point is small enough for
' condensation to occur. The macro's outputs--dew point and misting degree--are persisted in
' <_r13> and <_r11>, respectively.
'
' Note to modders / integrators intending to actually use these hooks: You might wish to additionally consider checking
' whether it is currently raining / snowing, and, if so, zero-out <_r11>, as you will otherwise end up having two
' textures--fog _and_ rain / snow--displayed on your windows at the same time, which might not be that
' aesthetically pleasing (unless your rain / snow rendering mechanism is inherently dynamic, of
' course).
'-----------------------------------------------------------------------------------------------------------------------
{macro:calculate_cabin_window_misting_degree}
    (L.L._r9) (C.L.cabin_window_misting_rel_humidity_min) (S.L._r11) - 0 max 1 (L.L._r11) - / (L.L._r10) d
        (F.L.dew_point_min_f_temp) (S.L._r13) - (L.L._r9) (F.L.dew_point_diff_f_rel_humidity) * (L.L._r13)
        + (L.L._r10) min d (S.L._r13) (C.L.cabin_window_misting_dew_point_threshold) +
        (C.L.cabin_window_misting_dew_point_error_tolerance) + < * 1 min (S.L._r11)
{end}
